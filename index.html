<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>wiklajs</title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="style.css">
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header>
<h1 class="title">wiklajs</h1>
</header>
<nav id="TOC">
<ul>
<li><a href="#week-1">Week 1</a><ul>
<li><a href="#types">Types</a></li>
<li><a href="#variable-hoisting">Variable hoisting</a></li>
<li><a href="#equality">Equality</a></li>
<li><a href="#functions-for-checking-data-types">Functions for checking data types</a></li>
</ul></li>
<li><a href="#week-2">Week 2</a><ul>
<li><a href="#algorithms-programming-styles">Algorithms &amp; programming styles</a></li>
<li><a href="#functional-vs-imperative">Functional vs imperative</a></li>
<li><a href="#exceptions">Exceptions</a></li>
<li><a href="#closures">Closures</a></li>
<li><a href="#objects">Objects</a></li>
</ul></li>
</ul>
</nav>
<p>Simple site for submitting answers for the exercises on the course &quot;Ohjelmointitekniikka: JavaScript&quot;.</p>
<p>Group members:</p>
<ul>
<li>Veeti &quot;walther&quot; Haapsamo</li>
<li>Pauli &quot;iluaP&quot; Niva</li>
<li>Niko &quot;aozi&quot; Novitsky</li>
<li>Ville &quot;vvainio&quot; Vainio</li>
</ul>
<h2 id="week-1">Week 1</h2>
<h3 id="types">Types</h3>
<p>JavaScript is a <em>loosely</em> typed or a <em>dynamic</em> language:</p>
<ul>
<li>Primitive datatypes:
<ul>
<li>Boolean</li>
<li>Null</li>
<li>Undefined</li>
<li>Number</li>
<li>String</li>
<li>Symbol (ECMAScript 6)</li>
</ul></li>
<li>and Object</li>
</ul>
<h3 id="variable-hoisting">Variable hoisting</h3>
<pre class="javascript"><code>var sum = 21;

function alertSum() {
    if (false) {
        var sum = 42;
    }

    alert(sum);
}

alertSum();</code></pre>
<p>Alerts <code>undefined</code>, not <code>42</code> or <code>21</code>!</p>
<p>Why? Because the JavaScript compiler interprets the code as follows:</p>
<pre class="javascript"><code>var sum = 21;

function alertSum() {
    var sum;

    if (false) {
        sum = 42;
    }

    alert(sum);
}

alertSum();</code></pre>
<h3 id="equality">Equality</h3>
<p>In JavaScript, there is a big difference between the functions <code>==</code>and <code>===</code>. See some differences in action:</p>
<pre class="javascript"><code>// These return true:
0     == &quot;0&quot;
0     == &quot;&quot;
false == &quot;0&quot;
null  == undefined
&quot; &quot;   == 0

// These return false:
&quot;&quot;    == &quot;0&quot;
false == &quot;false&quot;
false == undefined
false == null

// However, all these return false:
0     === &quot;0&quot;
0     === &quot;&quot;
false === &quot;0&quot;
null  === undefined
&quot; &quot;   === 0
</code></pre>
<p>These are caused by <em>type coercion</em>: when using a simple <code>==</code>for checking equality, the types of the parameters are coerced to match. A string is happily converted into a number, and so on. In some cases this might be useful, but it can also be a big source of confusion - use caution when using <code>==</code>. Usually it is better to just use <code>===</code> for stricter and more logical checking. In addition to making more sense, <code>===</code> can provide a performance boost, as there is no overhead from type conversion from coercion.</p>
<h3 id="functions-for-checking-data-types">Functions for checking data types</h3>
<p>Here are some example functions for checking the types of values.</p>
<pre class="javascript"><code>function isNumber(a) {
    return !isNaN(a) &amp;&amp; typeof a === &quot;number&quot;;
}

function isInt (a) {
    return isNumber(a) &amp;&amp; a % 1 === 0; // remainder with 1 must be explicitly 0
}

function isString(a) {
    return typeof a === &quot;string&quot;;
}

function isArray(a) {
    return Array.isArray(a);
}

function isArrayOfNumbers (a) {
    return isArray(a) &amp;&amp; a.every(isNumber);
}

function isArrayOfInts (a) {
    return isArray(a) &amp;&amp; a.every(isInt);
}

function isArrayOfString (a) {
    return isArray(a) &amp;&amp; a.every(isString);
}

function isBoolean(a) {
    return typeof a === &quot;boolean&quot;;
}

function isUndefined(a) {
    return typeof a === &quot;undefined&quot;;
}

function isNull(a) {
    return a === null;
}

// Tests

// number
console.assert(true === isNumber(5), &quot;isNumber 5&quot;);
console.assert(false === isNumber(&quot;5&quot;), &#39;not isNumber &quot;5&quot;&#39;);
// int
console.assert(true === isNumber(5), &quot;isNumber 5&quot;);
console.assert(false === isNumber(&quot;5&quot;), &#39;not isNumber &quot;5&quot;&#39;);
// string
console.assert(true === isString(&quot;5&quot;), &#39;isString &quot;5&quot;&#39;);
console.assert(false === isString(5), &#39;not isString 5&#39;);
// array
console.assert(true === isArray([&quot;5&quot;]), &#39;isArray [&quot;5&quot;]&#39;);
console.assert(false === isArray(5), &#39;not isArray 5&#39;);
// number array
console.assert(true === isArrayOfNumbers([5]), &#39;isArrayOfNumbers [5]&#39;);
console.assert(false === isArrayOfNumbers(5), &#39;not isArrayOfNumbers 5&#39;);
// int array
console.assert(true === isArrayOfInts([5]), &#39;isArrayOfInts [5]&#39;);
console.assert(false === isArrayOfInts([5.2]), &#39;not isArrayOfInts [5.2]&#39;);
// string array
console.assert(true === isArrayOfNumbers([5]), &#39;isArrayOfNumbers [5]&#39;);
console.assert(false === isArrayOfNumbers([&quot;5&quot;]), &#39;not isArrayOfNumbers [&quot;5&quot;]&#39;);</code></pre>
<h2 id="week-2">Week 2</h2>
<h3 id="algorithms-programming-styles">Algorithms &amp; programming styles</h3>
<p>Algorithms can be written in JavaScript just like with any other programming language [1]. However, due to the dynamic nature of JavaScript (as seen on Week 1), type errors are common and extra carefulness is required when programming. For example, automatic type coercion might result in unexpected behavior when attempting to submit data to a backend.</p>
<p>Lack of static typing might also slow developers down as bugs are harder to find (e.g. debugging the root cause of a crash) and code maintenance is more difficult (e.g. refactoring is risky without complete knowledge of dependencies). The recommended way to minimize such problems is to implement basic type checking. There are several tools and libraries for doing this, such as <a href="http://flowtype.org">Flow</a> - a static type checker by Facebook which is designed to find type errors.</p>
<p>An example of a function that would normally result in a crash when executing:</p>
<pre><code>function length(x) {
    return x.length;
}

var total = length(&#39;Hello&#39;) + length(null);</code></pre>
<p>Flow would catch this error at compile time and point out that <code>x</code> can be null (so its length property should not be accessed). [2]</p>
<p>The benefits of dynamic typing are immense and often overcome the aforementioned problems. Dynamic typing results in more concise &amp; less verbose code, enables easy use of &quot;hacks&quot; like duck-typing and monkey-patching, and makes it easier to write generic code.</p>
<p>When writing algorithms in JavaScript, functions should be kept short to increase legibility and to reduce the need of tracking different variable types. Declaring the types in comments is often used to describe the types of arguments passed:</p>
<pre><code>/*
 * @param {String} x
 * @param {String} y
 * @return {Boolean}
 */
function match(x, y) {
    return x === y;
}</code></pre>
<p>Same functionalities can be written in several ways, next is an example for getting the nth Fibonacci number.</p>
<p>Utilizing a loop:</p>
<pre><code>function fibonacci(n) {
    var a = 0, b = 1, f = 1;
    for(var i = 2; i &lt;= n; i++) {
        f = a + b;
        a = b;
        b = f;
    }
    return f;
}

&gt; fibonacci(12)
144</code></pre>
<p>As a recursive function:</p>
<pre><code>function fibonacci(n){
    return n &lt;= 1 ? n : (fibonacci(n-1) + fibonacci (n-2));
}

&gt; fibonacci(12)
144</code></pre>
<p>Usage of static code analysis tools are also highly recommended to detect errors and potential problems. They can be configured to match particular coding guidelines and conventions. One example of such tool is <a href="http://jshint.com/about/">JSHint</a>.</p>
<p>All in all, JavaScript is a very liberal language and leaves much of the responsibility to the programmer. There are multiple ways to implement similar functionalities and it's left to the programmer to decide what fits the purpose the best. Dynamic typing is a powerful feature if utilized correctly as it enables great flexibility. However, a good understanding of the language is required in order to recognize and minimize possible problems.</p>
<p>Links:</p>
<p><a href="https://github.com/mgechev/javascript-algorithms">JavaScript implementation of different computer science algorithms.</a></p>
<p><a href="http://flowtype.org">Flow, a new static type checker for JavaScript</a></p>
<p><a href="http://jshint.com/about/">JSHint - A Static Code Analysis Tool for JavaScript</a></p>
<h3 id="functional-vs-imperative">Functional vs imperative</h3>
<p>Officially, JavaScript is a multi-paradigm language: it allows for simple scripting as well as object-oriented programming, imperative as well as functional programming. Here we will focus on the two perhaps most opposing paradigms: functional versus imperative.</p>
<p>From the traditional imperative paradigm, JavaScript has the common structures of <code>while</code> and <code>for</code>-loops, <code>if</code>-<code>else</code> -blocks, <code>switch</code>-cases and so on. However, with the advent of ECMAScript 6, lots of functional features have been brought in, including <code>map</code>, <code>every</code>, <code>let</code> and so on. For a comprehensive list, see for example <a href="http://es6-features.org/">this</a> website!</p>
<p>Specific functions are not the paradigm's defining features though. Let's go deeper with some examples:</p>
<p><strong>Imperative approach</strong></p>
<pre class="javascript"><code>var nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

var even = function(a) {
  var ret = []
  for (var i=0; i&lt;nums.length; i++) {
    if (a[i] % 2 === 0) {
      ret.push(a[i]);
    }
  }
  return ret;
}

console.log(even(nums));</code></pre>
<p>Here we have a list of <code>nums</code>, integers from 1 to 10. We define <code>even</code>, a function that accumulates a list of return values by going through all the elements of the input list and checking if the number has a remainder of 0 when divided by 2. At the end, the <code>ret</code> list is returned.</p>
<p><strong>Functional approach</strong></p>
<pre class="javascript"><code>var nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

var even = xs =&gt; xs.filter(x =&gt; x % 2 == 0)

console.log(even(nums));</code></pre>
<p>Here we define <code>even</code> with arrow notation as a function that is essentially a lambda: input values xs tend towards a filtered version of xs, where the filter criterion is a lambda of divisibility by two.</p>
<p>See, we can make JavaScript look more like Haskell than C!</p>
<p>All joking aside, it is wonderful that JavaScript has support for both styles. This allows users to code in a way familiar to them or in the best ways relevant to the use-case at hand. However, in many cases functional style allows for shorter and more concise expression, which aids readability and hence maintainability of the code base. Another interesting effect of using functional approach, arrow notation and lambdas is that we do not explicitly define return arrays or any other state at all; the code is <em>pure</em>.</p>
<h3 id="exceptions">Exceptions</h3>
<p>Runtime errors, more familiarly known as exceptions are errors that happen while the program is running. Exceptions can be handled with JavaScript's error handling, that is, with try statements. The try statement consists of a try block, which contains one or more statements, and at least one catch clause or a finally clause, or both. That is, there are three forms of the try statement</p>
<ol type="1">
<li>try..catch</li>
<li>try..finally</li>
<li>try..catch..finally</li>
</ol>
<pre class="javascript"><code>try {
    Block of code to try
}
catch(err) {
    Block of code to handle errors
}
finally {
    Block of code to be executed regardless of the try..catch result
}</code></pre>
<pre class="javascript"><code>function myFunction() {
    var message, x;
    message = document.getElementById(&quot;message&quot;);
    message.innerHTML = &quot;&quot;;
    x = document.getElementById(&quot;demo&quot;).value;
    try {
        if(x == &quot;&quot;) throw &quot;is empty&quot;;
        if(isNaN(x)) throw &quot;is not a number&quot;;
        x = Number(x);
        if(x &gt; 10) throw &quot;is too high&quot;;
        if(x &lt; 5) throw &quot;is too low&quot;;
    }
    catch(err) {
        message.innerHTML = &quot;Error: &quot; + err + &quot;.&quot;;
    }
    finally {
        document.getElementById(&quot;demo&quot;).value = &quot;&quot;;
    }
}</code></pre>
<p>A catch clause specifies what to do if an exception is thrown in the try block. If the try block does not succeed, that is, if any statement within the try block (or in a method called from within the block) throws an exception, control shifts to the catch clause. If no exception is thrown in the try block, the catch clause is skipped. The finally clause always executes, regardless of whether or not an exception was thrown or caught. It executes after the try block and catch clause or clauses but before any statements following the try statement. Try statements can be nested. If an inner try statement does not have a catch clause, the enclosing try statement's catch clause is entered.</p>
<pre class="javascript"><code>try {
  try {
    throw new Error(&quot;inner&quot;);
  }
  finally {
    console.log(&quot;finally&quot;);
  }
}
catch (ex) {
  console.error(&quot;outer&quot;, ex.message);
}

// Output:
// &quot;finally&quot;
// &quot;outer&quot; &quot;inner&quot;</code></pre>
<p>When a single, unconditional catch clause is used, the catch block is entered when any exception is thrown. One can also use one or more conditional catch clauses to handle specific exceptions. This functionality is not part of the ECMAScript specification though. But in case you decide to use this kind of functionality, then the appropriate catch clause is entered when the specified exception is thrown. When an exception occurs, control is transferred to the appropriate catch clause. If the exception is not one of the specified exceptions and an unconditional catch clause is found, control transfers to that one.</p>
<p>Here is how to do implement the same conditional catch clauses using only simple JavaScript that does not conform to the ECMAScript specification:</p>
<pre class="javascript"><code>try {
    myroutine(); // may throw three types of exceptions
} catch (e if e instanceof TypeError) {
    // statements to handle TypeError exceptions
} catch (e if e instanceof RangeError) {
    // statements to handle RangeError exceptions
} catch (e if e instanceof EvalError) {
    // statements to handle EvalError exceptions
} catch (e) {
    // statements to handle any unspecified exceptions
    logMyErrors(e); // pass exception object to error handler
}</code></pre>
<p>Here is how to do implement the same conditional catch clauses using only simple JavaScript conforming to the ECMAScript specification:</p>
<pre class="javascript"><code>try {
    myroutine(); // may throw three types of exceptions
} catch (e) {
    if (e instanceof TypeError) {
        // statements to handle TypeError exceptions
    } else if (e instanceof RangeError) {
        // statements to handle RangeError exceptions
    } else if (e instanceof EvalError) {
        // statements to handle EvalError exceptions
    } else {
       // statements to handle any unspecified exceptions
       logMyErrors(e); // pass exception object to error handler
    }
}</code></pre>
<p>ECMAScript specifies six different kinds of exceptions.</p>
<ol type="1">
<li>EvalError, not in use, only included for backward compatibility's sake.</li>
<li>RangeError, if numerical value exceeds its range.</li>
<li>ReferenceError, for invalid references.</li>
<li>SyntaxError, for syntactical errors.</li>
<li>TypeError, if type deviates from expected type.</li>
<li>URIError, if global URI handling method are used improperly.</li>
</ol>
<p>When an exception is thrown in the try block, exception variable (the e in catch (e)) holds the value specified by the throw statement. This identifier can be used to get information about the thrown exception. This identifier is local to the catch clause. That is, it is created when the catch clause is entered, and after it finishes executing, the identifier is not available anymore.</p>
<p>The finally clause contains statements that are to be executed after the try and catch clauses execute, but before any statements following the try statement. As said earlier the finally clause executes regardless of whether an exception was thrown. If exception is thrown, then the statements in the finally clause will execute even if catch clause did not handle the exception. One can use the finally clause to make scripts fail gracefully when an exception occurs.</p>
<p>If the finally clause returns a value, then this value becomes the return value of the entire try statement, regardless of any return statements in the try and catch blocks.</p>
<p>The throw statement allows the creation of custom errors. Execution of the current function will stop (the statements after throw won't be executed), and control will be passed to the first catch block in the call stack. If no catch block exists among caller functions, the program will terminate.</p>
<p>The raised exception can be JavaScript String, Number, Boolean or an Object. Throw can be used alongside with try and catch to control program flow and generate custom error messages.</p>
<pre class="javascript"><code>throw &quot;Something happened&quot;;   // throws a String
throw 42;                     // throws a number
throw true;                   // throws a Boolean</code></pre>
<h3 id="closures">Closures</h3>
<p>Explaining what a closure is, is a bit difficult. It's easier to demonstrate it and expand from the examples provided.</p>
<p>Here is a simple function that uses a closure</p>
<pre class="javascript"><code>function sayHello(name) {
    var text = &#39;Hello &#39; + name; // Local variable
    var sayAlert = function() { alert(text); }
    return sayAlert;
}

var say2 = sayHello(&#39;Arto&#39;);
say2(); // alerts &quot;Hello Arto&quot;
</code></pre>
<p>So what exactly is going on here? We're first defining a new variable, we use the <code>sayHello</code> function with a parameter.</p>
<p>The <code>sayHello</code> function defines its own variable called text, however the text itself is not returned. Rather we define another function inside the <code>sayHello</code> function. This is the function that actually displays any text.</p>
<p>The interesting thing about closures, is that they can access all data contained in the environment where they were created. So in this case, the closure sees the text variable and can access it.</p>
<p>And finally, we actually return the <code>sayAlert</code> variable, which in itself is a function, that uses variables defined in the <code>sayHello</code> function.</p>
<p>Usually in programming languages when you return from a function, any reference to that function itself is removed. So in this case, the variable text should not be accessible since the function environment no longer exists.</p>
<p>Yet by calling the function with <code>say2();</code> we get the print defined in the text variable. Why is this?</p>
<p>As stated previously, a closure can access any data from the environment where it was created, however the closure also maintains a reference to the environment where it was defined, and this has a lot of interesting proeprties that can be used and abused (like most things in javascript...)</p>
<p>Here's a function that clearly shows that the variables are kept in reference, rather than just copied.</p>
<pre class="javascript"><code>function say666() {
    // Local variable that ends up within closure
    var num = 666;
    var sayAlert = function() {num++; alert(num); }
    return sayAlert;
}
var sayNumber = say666();
sayNumber(); // alerts 667
sayNumber(); // alerts 668
sayNumber(); // alerts 669</code></pre>
<p>Each call to the <code>sayNumber</code> object we defined, increments the result by one, the old result is also stored. So it is clear that reference to the original environment is kept, and the values are not just copied inside the closure.</p>
<p>This means that when we increment the number inside the closure, it's not stored in the closure, rather the closure accesses the parent function, and stores the number there, where it then again accesses it during the next call.</p>
<p>Now here's something a bit more interesting, what if we define global closure functions, inside a function?</p>
<pre class="javascript"><code>function setupSomeGlobals() {
    // Local variable that ends up within closure
    var num = 666;
    // Store some references to functions as global variables
    gAlertNumber    = function() { alert(num); }
    gIncreaseNumber = function() { num++; }
    gSetNumber      = function(x) { num = x; }
}

setupSomeGlobals();</code></pre>
<p>Right now we're not even instantiating an object, we're simply calling a function that defines it's variable, and few global functions.</p>
<p>So lets poke the stuff inside the function and see what happens!</p>
<pre class="javascript"><code>gAlertNumber(); //prints 666
gIncreaseNumber();
gAlertNumber(); //667
setupSomeGlobals();
gAlertNumber(); //prints 666!
gSetNumber(5);
gAlertNumber(); //prints 5</code></pre>
<p>All of these functions refer to the exact same closure! And when we call the original function again, the values are reset! Unless....</p>
<pre class="javascript"><code>var oldIncrease = gIncreaseNumber;
var oldValue = gAlertNumber;</code></pre>
<p>We store the reference into a new variable!</p>
<pre class="javascript"><code>setupSomeGlobals();
oldValue(); //Prints 5
oldIncrease();
oldValue(); //Prints 6!
gAlertNumber(); //Prints 666!</code></pre>
<p>So even though we defined global functions that all refer to the exact same closure, if we store a reference to these functions, they execute in the environment they were defined in! Even after the function terminates, even after we reset the closure where the global functions point to, if we store a reference to a function, it still executes within the environment that was in place when we define it! So the reference still exists there somewhere!</p>
<p>This has some unfortunate implications, that are still interesting to consider.</p>
<pre class="javascript"><code>function makeList(list) {
    var result = [];
    for (var i = 0; i &lt; list.length; i++) {
        var item = &#39;item&#39; + i;
        result.push( function() {alert(item + &#39; &#39; + list[i])} );
    }
    return result;
}

var weird = makeList([1,2,3,4,5]);

//testing the list
for (var j = 0; j &lt; weird.length; j++) {
    weird[j]();
}</code></pre>
<p>Looking at this, you would expect the function to generate a list that prints the item number on the screen for every item on the list. However what you get might be surprising.....</p>
<p>The function actually prints <code>item4 undefined</code> five times......Why? Because closures are evaluated in the environment they were defined in.</p>
<p>So when we first generate the list, we loopthrough the list we give as a parameter;</p>
<pre class="javascript"><code>for (var i = 0; i &lt; list.length; i++) {
    var item = &#39;item&#39; + i;
    result.push( function() {alert(item + &#39; &#39; + list[i])} );
}</code></pre>
<p>Thus far pretty easy, however we then use the <code>i</code> variable to index the elements....Because that's what we do with for loops, then things get weird. Because closures are weird.</p>
<pre class="javascript"><code>result.push( function() {alert(item + &#39; &#39; + list[i])} );</code></pre>
<p>So we push a new function to the list, a function which generates an alert based on the current index of the loop....except it doesn't. Because closures store the reference environment and use that to deal with variables, and in addition they are evaluated when called, not when generated.</p>
<p>We use the function to generate the alert, and store that in the result list. But when we try to call the function of the specific item on the list, the closure goes and sees that the variable <code>i</code>, which we used for our loop, is actually 4, because we iterated through the list!</p>
<p>So it simply sees that <code>i = 4</code> and since nothing changes it, everything is evaluated to <code>item4 undefined</code>.</p>
<h3 id="objects">Objects</h3>
<p>Olioita voidaan luoda monin tavoin, kenttiä voidaan lisätä ja poistaa, kenttiin voidaan viitata eri tavoin, myös dynaamisesti, kentän nimeksi kelpaa miltei mitä tahansa.</p>
<p>There arte numerous ways to create objects in javascript, each of them has its own special use and niche it fits in, so there is really no &quot;best&quot; solution. Every approach can be used in almost any circumstances but they all have their strengths and weaknesses.</p>
<p>Let's start with something simple, an object literal</p>
<pre class="javascript"><code>    var person = { 
        name : &quot;Wikla&quot;,
        getName : function (){
            return this.name
        } 
    } </code></pre>
<p>We're creating an object called person with its own proeprties and function declared right there. This means we can't actually create instances of this object, so the main use of this is to create single objects.</p>
<p>Next up, the object constructor</p>
<pre class="javascript"><code>    var person = new Object();

    person.name = &quot;Wikla&quot;,
    person.getName = function(){
        return this.name ; 
    };</code></pre>
<p>This is slightly different, we're first using the <code>ne</code> keyword to create an isntance of the base class `Object. We then proceed to use the traditional javasdcript syntax to add more fields to this new object. Javascript actually allows us to add new fields to an object easily.</p>
<p>Next up, the function constructor</p>
<pre class="javascript"><code>    function Person(name){
      this.name = name
      this.getName = function(){
        return this.name
      } 
    } </code></pre>
<p>This would be the closest to something like Java. We're creating a new function that serves as the constructor function whenever we create a new instance of this object. This approach has the obvious benefit of being able to create multiple objects from the same constructor but with different properties.</p>
<p>Next up is the prototype way</p>
<pre class="javascript"><code>    function Person(){};
    Person.prototype.name = &quot;Wikla&quot;;</code></pre>
<p>Now what's going on here? We're first creating a new function called Person, just like with functions constructors. However we leave everything empty, but Javascript still creates a constructor function that sets up all the basic fields javascript objects have, such as the <code>prototype</code> field. The `prototype field in this case, refers to the constructor function which is used to create an instance of the Person object. By adding new field to this, we're also adding new fields to any future instances created from this function.</p>
<p>We can also combine any of these approaches, for example, here's a combination of function constructors and prototypes</p>
<pre class="javascript"><code>    function Person(name){
      this.name = name;
    } 
    Person.prototype.getName = function(){
      return this.name
    } </code></pre>
<p>So we first create a new function called <code>Person</code>, this function contains a single value `name. We then use the prototype field like in the previous example, to add properties to the function prototype. This time we add in an actual function that returns the name. Since we're adding this to the Person prototype, which has the proeprty name already, this getName function can obviously see it.</p>
<p>One more thing worth mentioning is the <code>Object.create()</code> function. For the most part it works exactly the same as the new function, with one major difference. <code>Object.create()</code> allows you to define the prototype of the object you're creating. When using a constructor function, the object inherits properties directly from the constructor's prototype. You can also define objects inside the object.create argument definitions.</p>
<p>To put it simple:</p>
<pre class="javascript"><code>    var a = new Person();</code></pre>
<p>Is equal to:</p>
<pre class="javascript"><code>    var a = Object.create(Person.prototype);</code></pre>
<p>As mentioned before, we can quite freely add field to an object or the object prototype, in fact we can climb up the prototype chain using the <code>__proto__</code> field in order to assign new fields and properties to anything in the chain.</p>
<p>This is of course not very sensible nor advised, you can easily break literally everything by making amsitake in the prototype chain. But as a property of Javascript, it is a good idea to learn it and make use of it, carefully.</p>
<p>One very interesting property of javascript is the ability to dynamically name fields, simply put you can use variables to name any field or other variable inside an object.</p>
<pre class="javascript"><code>    function foobar(arg1) {
       this.a = arg1;

       name = this[&#39;a&#39;];
       alert(name);
    }
    new foobar(&quot;Javascript&quot;);</code></pre>
<p>This, once again can be extremely powerful and extremely easy to screw up and break your entire codebase.</p>
<p>Ideally you'd want to stick with one type of Object declarations to make your code easily readable, branch out if the other styles provide you with some benefit you wouldn't get elesewhere.</p>
<p>Now how do you make the best use of objects in Javascript? One good thing to do is to make good use of modules. Modules are a design pattern in Javascript that allows you to easily create public and private functions, along with encapsulating data.</p>
<pre class="javascript"><code>      MyNamespace.MyModule = function()
      {
        var myPrivateProperty = 2;
        var myPublicProperty = 1;
        var myPrivateFunction = function()
        {
          console.log(&quot;myPrivateFunction()&quot;);
        };
        var myPublicFunction = function()
        {
          console.log(&quot;myPublicFunction()&quot;);
          myPrivateFunction();
        };
        var init = function()
        {
          console.log(&quot;init()&quot;);
        };
        var oPublic =
        {
          init: init,
          myPublicProperty: myPublicProperty,
          myPublicFunction: myPublicFunction
        };
        return oPublic;
      }();</code></pre>
<p>You might notice how the syntax for public and private properties is exactly the same. So how does this work exactly? Instead of creating an instance of the fucntion we defined, the function itself returns an object literal that we define.</p>
<p>This function ltieral stores the functions definitions we have created and allows us to use the public properties, the public properties can use private properties since we have defined them inside the module. And all of this works primarily thanks to Closures which allow us to keep the contents of the function alive even atfer it is discarded by the garbage collector.</p>
<link rel="stylesheet" type="text/css" href="http://walther.guru/hilightjs_monokai.css">
<script src="http://walther.guru/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
</body>
</html>
