<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>wiklajs</title>
  <style type="text/css">code{white-space: pre;}</style>
  <!--[if lt IE 9]>
    <script src="http://html5shim.googlecode.com/svn/trunk/html5.js"></script>
  <![endif]-->
  <link rel="stylesheet" href="style.css">
</head>
<body>
<header>
<h1 class="title">wiklajs</h1>
</header>
<nav id="TOC">
<ul>
<li><a href="#week-1">Week 1</a><ul>
<li><a href="#types">Types</a></li>
<li><a href="#variable-hoisting">Variable hoisting</a></li>
<li><a href="#equality">Equality</a></li>
<li><a href="#functions-for-checking-data-types">Functions for checking data types</a></li>
</ul></li>
<li><a href="#week-2">Week 2</a><ul>
<li><a href="#algorithm-styles">Algorithm styles</a></li>
<li><a href="#functional-vs-imperative">Functional vs imperative</a></li>
<li><a href="#closures">Closures</a></li>
<li><a href="#exceptions">Exceptions</a></li>
</ul></li>
</ul>
</nav>
<p>Simple site for submitting answers for the exercises on the course &quot;Ohjelmointitekniikka: JavaScript&quot;.</p>
<p>Group members:</p>
<ul>
<li>veeti &quot;walther&quot; haapsamo</li>
<li>pauli &quot;iluaP&quot; niva</li>
<li>ville &quot;vvainio&quot; vainio</li>
<li>niko &quot;aozi&quot; novitsky</li>
</ul>
<h2 id="week-1">Week 1</h2>
<h3 id="types">Types</h3>
<p>JavaScript is a <em>loosely</em> typed or a <em>dynamic</em> language:</p>
<ul>
<li>Primitive datatypes:
<ul>
<li>Boolean</li>
<li>Null</li>
<li>Undefined</li>
<li>Number</li>
<li>String</li>
<li>Symbol (ECMAScript 6)</li>
</ul></li>
<li>and Object</li>
</ul>
<h3 id="variable-hoisting">Variable hoisting</h3>
<pre class="javascript"><code>var sum = 21;

function alertSum() {
    if (false) {
        var sum = 42;
    }

    alert(sum);
}

alertSum();</code></pre>
<p>Alerts <code>undefined</code>, not <code>42</code> or <code>21</code>!</p>
<p>Why? Because the JavaScript compiler interprets the code as follows:</p>
<pre class="javascript"><code>var sum = 21;

function alertSum() {
    var sum;

    if (false) {
        sum = 42;
    }

    alert(sum);
}

alertSum();</code></pre>
<h3 id="equality">Equality</h3>
<p>In JavaScript, there is a big difference between the functions <code>==</code>and <code>===</code>. See some differences in action:</p>
<pre class="javascript"><code>// These return true:
0     == &quot;0&quot;
0     == &quot;&quot;
false == &quot;0&quot;
null  == undefined
&quot; &quot;   == 0

// These return false:
&quot;&quot;    == &quot;0&quot;
false == &quot;false&quot;
false == undefined
false == null

// However, all these return false:
0     === &quot;0&quot;
0     === &quot;&quot;
false === &quot;0&quot;
null  === undefined
&quot; &quot;   === 0
</code></pre>
<p>These are caused by <em>type coercion</em>: when using a simple <code>==</code>for checking equality, the types of the parameters are coerced to match. A string is happily converted into a number, and so on. In some cases this might be useful, but it can also be a big source of confusion - use caution when using <code>==</code>. Usually it is better to just use <code>===</code> for stricter and more logical checking. In addition to making more sense, <code>===</code> can provide a performance boost, as there is no overhead from type conversion from coercion.</p>
<h3 id="functions-for-checking-data-types">Functions for checking data types</h3>
<p>Here are some example functions for checking the types of values.</p>
<pre class="javascript"><code>function isNumber(a) {
    return !isNaN(a) &amp;&amp; typeof a === &quot;number&quot;;
}

function isInt (a) {
    return isNumber(a) &amp;&amp; a % 1 === 0; // remainder with 1 must be explicitly 0
}

function isString(a) {
    return typeof a === &quot;string&quot;;
}

function isArray(a) {
    return Array.isArray(a);
}

function isArrayOfNumbers (a) {
    return isArray(a) &amp;&amp; a.every(isNumber);
}

function isArrayOfInts (a) {
    return isArray(a) &amp;&amp; a.every(isInt);
}

function isArrayOfString (a) {
    return isArray(a) &amp;&amp; a.every(isString);
}

function isBoolean(a) {
    return typeof a === &quot;boolean&quot;;
}

function isUndefined(a) {
    return typeof a === &quot;undefined&quot;;
}

function isNull(a) {
    return a === null;
}

// Tests

// number
console.assert(true === isNumber(5), &quot;isNumber 5&quot;);
console.assert(false === isNumber(&quot;5&quot;), &#39;not isNumber &quot;5&quot;&#39;);
// int
console.assert(true === isNumber(5), &quot;isNumber 5&quot;);
console.assert(false === isNumber(&quot;5&quot;), &#39;not isNumber &quot;5&quot;&#39;);
// string
console.assert(true === isString(&quot;5&quot;), &#39;isString &quot;5&quot;&#39;);
console.assert(false === isString(5), &#39;not isString 5&#39;);
// array
console.assert(true === isArray([&quot;5&quot;]), &#39;isArray [&quot;5&quot;]&#39;);
console.assert(false === isArray(5), &#39;not isArray 5&#39;);
// number array
console.assert(true === isArrayOfNumbers([5]), &#39;isArrayOfNumbers [5]&#39;);
console.assert(false === isArrayOfNumbers(5), &#39;not isArrayOfNumbers 5&#39;);
// int array
console.assert(true === isArrayOfInts([5]), &#39;isArrayOfInts [5]&#39;);
console.assert(false === isArrayOfInts([5.2]), &#39;not isArrayOfInts [5.2]&#39;);
// string array
console.assert(true === isArrayOfNumbers([5]), &#39;isArrayOfNumbers [5]&#39;);
console.assert(false === isArrayOfNumbers([&quot;5&quot;]), &#39;not isArrayOfNumbers [&quot;5&quot;]&#39;);</code></pre>
<h2 id="week-2">Week 2</h2>
<h3 id="algorithm-styles">Algorithm styles</h3>
<h3 id="functional-vs-imperative">Functional vs imperative</h3>
<h3 id="closures">Closures</h3>
<h3 id="exceptions">Exceptions</h3>
<link rel="stylesheet" type="text/css" href="http://walther.guru/hilightjs_monokai.css">
<script src="http://walther.guru/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
</body>
</html>
