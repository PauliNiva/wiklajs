<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta name="generator" content="pandoc">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">
  <title>wiklajs</title>
  <style type="text/css">code{white-space: pre;}</style>
  <link rel="stylesheet" href="style.css">
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<header>
<h1 class="title">wiklajs</h1>
</header>
<nav id="TOC">
<ul>
<li><a href="#week-1">Week 1</a><ul>
<li><a href="#types">Types</a></li>
<li><a href="#variable-hoisting">Variable hoisting</a></li>
<li><a href="#equality">Equality</a></li>
<li><a href="#functions-for-checking-data-types">Functions for checking data types</a></li>
</ul></li>
<li><a href="#week-2">Week 2</a><ul>
<li><a href="#algorithm-styles">Algorithm styles</a></li>
<li><a href="#functional-vs-imperative">Functional vs imperative</a></li>
<li><a href="#exceptions">Exceptions</a></li>
<li><a href="#closures">Closures</a></li>
</ul></li>
</ul>
</nav>
<p>Simple site for submitting answers for the exercises on the course &quot;Ohjelmointitekniikka: JavaScript&quot;.</p>
<p>Group members:</p>
<ul>
<li>veeti &quot;walther&quot; haapsamo</li>
<li>pauli &quot;iluaP&quot; niva</li>
<li>ville &quot;vvainio&quot; vainio</li>
<li>niko &quot;aozi&quot; novitsky</li>
</ul>
<h2 id="week-1">Week 1</h2>
<h3 id="types">Types</h3>
<p>JavaScript is a <em>loosely</em> typed or a <em>dynamic</em> language:</p>
<ul>
<li>Primitive datatypes:
<ul>
<li>Boolean</li>
<li>Null</li>
<li>Undefined</li>
<li>Number</li>
<li>String</li>
<li>Symbol (ECMAScript 6)</li>
</ul></li>
<li>and Object</li>
</ul>
<h3 id="variable-hoisting">Variable hoisting</h3>
<pre class="javascript"><code>var sum = 21;

function alertSum() {
    if (false) {
        var sum = 42;
    }

    alert(sum);
}

alertSum();</code></pre>
<p>Alerts <code>undefined</code>, not <code>42</code> or <code>21</code>!</p>
<p>Why? Because the JavaScript compiler interprets the code as follows:</p>
<pre class="javascript"><code>var sum = 21;

function alertSum() {
    var sum;

    if (false) {
        sum = 42;
    }

    alert(sum);
}

alertSum();</code></pre>
<h3 id="equality">Equality</h3>
<p>In JavaScript, there is a big difference between the functions <code>==</code>and <code>===</code>. See some differences in action:</p>
<pre class="javascript"><code>// These return true:
0     == &quot;0&quot;
0     == &quot;&quot;
false == &quot;0&quot;
null  == undefined
&quot; &quot;   == 0

// These return false:
&quot;&quot;    == &quot;0&quot;
false == &quot;false&quot;
false == undefined
false == null

// However, all these return false:
0     === &quot;0&quot;
0     === &quot;&quot;
false === &quot;0&quot;
null  === undefined
&quot; &quot;   === 0
</code></pre>
<p>These are caused by <em>type coercion</em>: when using a simple <code>==</code>for checking equality, the types of the parameters are coerced to match. A string is happily converted into a number, and so on. In some cases this might be useful, but it can also be a big source of confusion - use caution when using <code>==</code>. Usually it is better to just use <code>===</code> for stricter and more logical checking. In addition to making more sense, <code>===</code> can provide a performance boost, as there is no overhead from type conversion from coercion.</p>
<h3 id="functions-for-checking-data-types">Functions for checking data types</h3>
<p>Here are some example functions for checking the types of values.</p>
<pre class="javascript"><code>function isNumber(a) {
    return !isNaN(a) &amp;&amp; typeof a === &quot;number&quot;;
}

function isInt (a) {
    return isNumber(a) &amp;&amp; a % 1 === 0; // remainder with 1 must be explicitly 0
}

function isString(a) {
    return typeof a === &quot;string&quot;;
}

function isArray(a) {
    return Array.isArray(a);
}

function isArrayOfNumbers (a) {
    return isArray(a) &amp;&amp; a.every(isNumber);
}

function isArrayOfInts (a) {
    return isArray(a) &amp;&amp; a.every(isInt);
}

function isArrayOfString (a) {
    return isArray(a) &amp;&amp; a.every(isString);
}

function isBoolean(a) {
    return typeof a === &quot;boolean&quot;;
}

function isUndefined(a) {
    return typeof a === &quot;undefined&quot;;
}

function isNull(a) {
    return a === null;
}

// Tests

// number
console.assert(true === isNumber(5), &quot;isNumber 5&quot;);
console.assert(false === isNumber(&quot;5&quot;), &#39;not isNumber &quot;5&quot;&#39;);
// int
console.assert(true === isNumber(5), &quot;isNumber 5&quot;);
console.assert(false === isNumber(&quot;5&quot;), &#39;not isNumber &quot;5&quot;&#39;);
// string
console.assert(true === isString(&quot;5&quot;), &#39;isString &quot;5&quot;&#39;);
console.assert(false === isString(5), &#39;not isString 5&#39;);
// array
console.assert(true === isArray([&quot;5&quot;]), &#39;isArray [&quot;5&quot;]&#39;);
console.assert(false === isArray(5), &#39;not isArray 5&#39;);
// number array
console.assert(true === isArrayOfNumbers([5]), &#39;isArrayOfNumbers [5]&#39;);
console.assert(false === isArrayOfNumbers(5), &#39;not isArrayOfNumbers 5&#39;);
// int array
console.assert(true === isArrayOfInts([5]), &#39;isArrayOfInts [5]&#39;);
console.assert(false === isArrayOfInts([5.2]), &#39;not isArrayOfInts [5.2]&#39;);
// string array
console.assert(true === isArrayOfNumbers([5]), &#39;isArrayOfNumbers [5]&#39;);
console.assert(false === isArrayOfNumbers([&quot;5&quot;]), &#39;not isArrayOfNumbers [&quot;5&quot;]&#39;);</code></pre>
<h2 id="week-2">Week 2</h2>
<h3 id="algorithm-styles">Algorithm styles</h3>
<h3 id="functional-vs-imperative">Functional vs imperative</h3>
<p>Officially, JavaScript is a multi-paradigm language: it allows for simple scripting as well as object-oriented programming, imperative as well as functional programming. Here we will focus on the two perhaps most opposing paradigms: functional versus imperative.</p>
<p>From the traditional imperative paradigm, JavaScript has the common structures of <code>while</code> and <code>for</code>-loops, <code>if</code>-<code>else</code> -blocks, <code>switch</code>-cases and so on. However, with the advent of ECMAScript 6, lots of functional features have been brought in, including <code>map</code>, <code>every</code>, <code>let</code> and so on. For a comprehensive list, see for example <a href="http://es6-features.org/">this</a> website!</p>
<p>Specific functions are not the paradigm's defining features though. Let's go deeper with some examples:</p>
<p><strong>Imperative approach</strong></p>
<pre class="javascript"><code>var nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

var even = function(a) {
  var ret = []
  for (var i=0; i&lt;nums.length; i++) {
    if (a[i] % 2 === 0) {
      ret.push(a[i]);
    }
  }
  return ret;
}

console.log(even(nums));</code></pre>
<p><strong>Functional approach</strong></p>
<pre class="javascript"><code>var nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]

var even = xs =&gt; xs.filter(x =&gt; x % 2 == 0)

console.log(even(nums));</code></pre>
<p>See, we can make JavaScript look more like Haskell than C!</p>
<p>All joking aside, it is wonderful that JavaScript has support for both styles. This allows users to code in a way familiar to them or in the best ways relevant to the use-case at hand. However, in many cases functional style allows for shorter and more concise expression, which aids readability and hence maintainability of the code base.</p>
<p><strong>TODO: improve this section. Not a lot of good content yet :(</strong></p>
<h3 id="exceptions">Exceptions</h3>
<p>Runtime errors, more familiarly known as exceptions are errors that happen while the program is running. Exceptions can be handled with JavaScript's error handling, that is, with try statements. The try statement consists of a try block, which contains one or more statements, and at least one catch clause or a finally clause, or both. That is, there are three forms of the try statement<br /></p>
<ol type="1">
<li>try..catch<br /></li>
<li>try..finally<br /></li>
<li>try..catch..finally<br /></li>
</ol>
<p>A catch clause specifies what to do if an exception is thrown in the try block. If the try block does not succeed, that is, if any statement within the try block (or in a method called from within the block) throws an exception, control shifts to the catch clause. If no exception is thrown in the try block, the catch clause is skipped. The finally clause always executes, regardless of whether or not an exception was thrown or caught. It executes after the try block and catch clause or clauses but before any statements following the try statement. Try statements can be nested. If an inner try statement does not have a catch clause, the enclosing try statement's catch clause is entered.</p>
<p>When a single, unconditional catch clause is used, the catch block is entered when any exception is thrown. One can also use one or more conditional catch clauses to handle specific exceptions. This functionality is not part of the ECMAScript specification though. But in case you decide to use this kind of functionality, then the appropriate catch clause is entered when the specified exception is thrown. When an exception occurs, control is transferred to the appropriate catch clause. If the exception is not one of the specified exceptions and an unconditional catch clause is found, control transfers to that one.</p>
<p>ECMAScript specifies six different kinds of exceptions.<br /></p>
<ol type="1">
<li>EvalError, not in use, only included for backward compatibility's sake.<br /></li>
<li>RangeError, if numerical value exceeds its range.<br /></li>
<li>ReferenceError, for invalid references.<br /></li>
<li>SyntaxError, for syntactical errors.<br /></li>
<li>TypeError, if type deviates from expected type.<br /></li>
<li>URIError, if global URI handling method are used improperly.<br /></li>
</ol>
<p>When an exception is thrown in the try block, exception variable (the e in catch (e)) holds the value specified by the throw statement. This identifier can be used to get information about the thrown exception. This identifier is local to the catch clause. That is, it is created when the catch clause is entered, and after it finishes executing, the identifier is not available anymore.</p>
<p>The finally clause contains statements that are to be executed after the try and catch clauses execute, but before any statements following the try statement. As said earlier the finally clause executes regardless of whether an exception was thrown. If exception is thrown, then the statements in the finally clause will execute even if catch clause did not handle the exception. One can use the finally clause to make scripts fail gracefully when an exception occurs.</p>
<p>If the finally clause returns a value, then this value becomes the return value of the entire try statement, regardless of any return statements in the try and catch blocks.</p>
<h3 id="closures">Closures</h3>
<link rel="stylesheet" type="text/css" href="http://walther.guru/hilightjs_monokai.css">
<script src="http://walther.guru/highlight.pack.js"></script>
<script>hljs.initHighlightingOnLoad();</script>
</body>
</html>
